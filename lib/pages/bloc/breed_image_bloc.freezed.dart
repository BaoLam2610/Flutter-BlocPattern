// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'breed_image_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BreedImageEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() get,
    required TResult Function() refresh,
    required TResult Function(int offset) loadMore,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? get,
    TResult? Function()? refresh,
    TResult? Function(int offset)? loadMore,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? get,
    TResult Function()? refresh,
    TResult Function(int offset)? loadMore,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetBreedImage value) get,
    required TResult Function(RefreshBreedImage value) refresh,
    required TResult Function(LoadMoreBreedImage value) loadMore,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetBreedImage value)? get,
    TResult? Function(RefreshBreedImage value)? refresh,
    TResult? Function(LoadMoreBreedImage value)? loadMore,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetBreedImage value)? get,
    TResult Function(RefreshBreedImage value)? refresh,
    TResult Function(LoadMoreBreedImage value)? loadMore,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BreedImageEventCopyWith<$Res> {
  factory $BreedImageEventCopyWith(
          BreedImageEvent value, $Res Function(BreedImageEvent) then) =
      _$BreedImageEventCopyWithImpl<$Res, BreedImageEvent>;
}

/// @nodoc
class _$BreedImageEventCopyWithImpl<$Res, $Val extends BreedImageEvent>
    implements $BreedImageEventCopyWith<$Res> {
  _$BreedImageEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetBreedImageImplCopyWith<$Res> {
  factory _$$GetBreedImageImplCopyWith(
          _$GetBreedImageImpl value, $Res Function(_$GetBreedImageImpl) then) =
      __$$GetBreedImageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetBreedImageImplCopyWithImpl<$Res>
    extends _$BreedImageEventCopyWithImpl<$Res, _$GetBreedImageImpl>
    implements _$$GetBreedImageImplCopyWith<$Res> {
  __$$GetBreedImageImplCopyWithImpl(
      _$GetBreedImageImpl _value, $Res Function(_$GetBreedImageImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetBreedImageImpl implements GetBreedImage {
  const _$GetBreedImageImpl();

  @override
  String toString() {
    return 'BreedImageEvent.get()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetBreedImageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() get,
    required TResult Function() refresh,
    required TResult Function(int offset) loadMore,
  }) {
    return get();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? get,
    TResult? Function()? refresh,
    TResult? Function(int offset)? loadMore,
  }) {
    return get?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? get,
    TResult Function()? refresh,
    TResult Function(int offset)? loadMore,
    required TResult orElse(),
  }) {
    if (get != null) {
      return get();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetBreedImage value) get,
    required TResult Function(RefreshBreedImage value) refresh,
    required TResult Function(LoadMoreBreedImage value) loadMore,
  }) {
    return get(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetBreedImage value)? get,
    TResult? Function(RefreshBreedImage value)? refresh,
    TResult? Function(LoadMoreBreedImage value)? loadMore,
  }) {
    return get?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetBreedImage value)? get,
    TResult Function(RefreshBreedImage value)? refresh,
    TResult Function(LoadMoreBreedImage value)? loadMore,
    required TResult orElse(),
  }) {
    if (get != null) {
      return get(this);
    }
    return orElse();
  }
}

abstract class GetBreedImage implements BreedImageEvent {
  const factory GetBreedImage() = _$GetBreedImageImpl;
}

/// @nodoc
abstract class _$$RefreshBreedImageImplCopyWith<$Res> {
  factory _$$RefreshBreedImageImplCopyWith(_$RefreshBreedImageImpl value,
          $Res Function(_$RefreshBreedImageImpl) then) =
      __$$RefreshBreedImageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RefreshBreedImageImplCopyWithImpl<$Res>
    extends _$BreedImageEventCopyWithImpl<$Res, _$RefreshBreedImageImpl>
    implements _$$RefreshBreedImageImplCopyWith<$Res> {
  __$$RefreshBreedImageImplCopyWithImpl(_$RefreshBreedImageImpl _value,
      $Res Function(_$RefreshBreedImageImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RefreshBreedImageImpl implements RefreshBreedImage {
  const _$RefreshBreedImageImpl();

  @override
  String toString() {
    return 'BreedImageEvent.refresh()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RefreshBreedImageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() get,
    required TResult Function() refresh,
    required TResult Function(int offset) loadMore,
  }) {
    return refresh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? get,
    TResult? Function()? refresh,
    TResult? Function(int offset)? loadMore,
  }) {
    return refresh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? get,
    TResult Function()? refresh,
    TResult Function(int offset)? loadMore,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetBreedImage value) get,
    required TResult Function(RefreshBreedImage value) refresh,
    required TResult Function(LoadMoreBreedImage value) loadMore,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetBreedImage value)? get,
    TResult? Function(RefreshBreedImage value)? refresh,
    TResult? Function(LoadMoreBreedImage value)? loadMore,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetBreedImage value)? get,
    TResult Function(RefreshBreedImage value)? refresh,
    TResult Function(LoadMoreBreedImage value)? loadMore,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class RefreshBreedImage implements BreedImageEvent {
  const factory RefreshBreedImage() = _$RefreshBreedImageImpl;
}

/// @nodoc
abstract class _$$LoadMoreBreedImageImplCopyWith<$Res> {
  factory _$$LoadMoreBreedImageImplCopyWith(_$LoadMoreBreedImageImpl value,
          $Res Function(_$LoadMoreBreedImageImpl) then) =
      __$$LoadMoreBreedImageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int offset});
}

/// @nodoc
class __$$LoadMoreBreedImageImplCopyWithImpl<$Res>
    extends _$BreedImageEventCopyWithImpl<$Res, _$LoadMoreBreedImageImpl>
    implements _$$LoadMoreBreedImageImplCopyWith<$Res> {
  __$$LoadMoreBreedImageImplCopyWithImpl(_$LoadMoreBreedImageImpl _value,
      $Res Function(_$LoadMoreBreedImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
  }) {
    return _then(_$LoadMoreBreedImageImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LoadMoreBreedImageImpl implements LoadMoreBreedImage {
  const _$LoadMoreBreedImageImpl({required this.offset});

  @override
  final int offset;

  @override
  String toString() {
    return 'BreedImageEvent.loadMore(offset: $offset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadMoreBreedImageImpl &&
            (identical(other.offset, offset) || other.offset == offset));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadMoreBreedImageImplCopyWith<_$LoadMoreBreedImageImpl> get copyWith =>
      __$$LoadMoreBreedImageImplCopyWithImpl<_$LoadMoreBreedImageImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() get,
    required TResult Function() refresh,
    required TResult Function(int offset) loadMore,
  }) {
    return loadMore(offset);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? get,
    TResult? Function()? refresh,
    TResult? Function(int offset)? loadMore,
  }) {
    return loadMore?.call(offset);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? get,
    TResult Function()? refresh,
    TResult Function(int offset)? loadMore,
    required TResult orElse(),
  }) {
    if (loadMore != null) {
      return loadMore(offset);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetBreedImage value) get,
    required TResult Function(RefreshBreedImage value) refresh,
    required TResult Function(LoadMoreBreedImage value) loadMore,
  }) {
    return loadMore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetBreedImage value)? get,
    TResult? Function(RefreshBreedImage value)? refresh,
    TResult? Function(LoadMoreBreedImage value)? loadMore,
  }) {
    return loadMore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetBreedImage value)? get,
    TResult Function(RefreshBreedImage value)? refresh,
    TResult Function(LoadMoreBreedImage value)? loadMore,
    required TResult orElse(),
  }) {
    if (loadMore != null) {
      return loadMore(this);
    }
    return orElse();
  }
}

abstract class LoadMoreBreedImage implements BreedImageEvent {
  const factory LoadMoreBreedImage({required final int offset}) =
      _$LoadMoreBreedImageImpl;

  int get offset;
  @JsonKey(ignore: true)
  _$$LoadMoreBreedImageImplCopyWith<_$LoadMoreBreedImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BreedImageState {
  UiState get state => throw _privateConstructorUsedError;
  List<BreedImage> get images => throw _privateConstructorUsedError;
  BreedImageNotification? get notification =>
      throw _privateConstructorUsedError;
  String? get errorMessage => throw _privateConstructorUsedError;
  String? get sucessMessage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BreedImageStateCopyWith<BreedImageState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BreedImageStateCopyWith<$Res> {
  factory $BreedImageStateCopyWith(
          BreedImageState value, $Res Function(BreedImageState) then) =
      _$BreedImageStateCopyWithImpl<$Res, BreedImageState>;
  @useResult
  $Res call(
      {UiState state,
      List<BreedImage> images,
      BreedImageNotification? notification,
      String? errorMessage,
      String? sucessMessage});

  $BreedImageNotificationCopyWith<$Res>? get notification;
}

/// @nodoc
class _$BreedImageStateCopyWithImpl<$Res, $Val extends BreedImageState>
    implements $BreedImageStateCopyWith<$Res> {
  _$BreedImageStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? state = null,
    Object? images = null,
    Object? notification = freezed,
    Object? errorMessage = freezed,
    Object? sucessMessage = freezed,
  }) {
    return _then(_value.copyWith(
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as UiState,
      images: null == images
          ? _value.images
          : images // ignore: cast_nullable_to_non_nullable
              as List<BreedImage>,
      notification: freezed == notification
          ? _value.notification
          : notification // ignore: cast_nullable_to_non_nullable
              as BreedImageNotification?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      sucessMessage: freezed == sucessMessage
          ? _value.sucessMessage
          : sucessMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $BreedImageNotificationCopyWith<$Res>? get notification {
    if (_value.notification == null) {
      return null;
    }

    return $BreedImageNotificationCopyWith<$Res>(_value.notification!, (value) {
      return _then(_value.copyWith(notification: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$BreedImageStateImplCopyWith<$Res>
    implements $BreedImageStateCopyWith<$Res> {
  factory _$$BreedImageStateImplCopyWith(_$BreedImageStateImpl value,
          $Res Function(_$BreedImageStateImpl) then) =
      __$$BreedImageStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {UiState state,
      List<BreedImage> images,
      BreedImageNotification? notification,
      String? errorMessage,
      String? sucessMessage});

  @override
  $BreedImageNotificationCopyWith<$Res>? get notification;
}

/// @nodoc
class __$$BreedImageStateImplCopyWithImpl<$Res>
    extends _$BreedImageStateCopyWithImpl<$Res, _$BreedImageStateImpl>
    implements _$$BreedImageStateImplCopyWith<$Res> {
  __$$BreedImageStateImplCopyWithImpl(
      _$BreedImageStateImpl _value, $Res Function(_$BreedImageStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? state = null,
    Object? images = null,
    Object? notification = freezed,
    Object? errorMessage = freezed,
    Object? sucessMessage = freezed,
  }) {
    return _then(_$BreedImageStateImpl(
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as UiState,
      images: null == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<BreedImage>,
      notification: freezed == notification
          ? _value.notification
          : notification // ignore: cast_nullable_to_non_nullable
              as BreedImageNotification?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      sucessMessage: freezed == sucessMessage
          ? _value.sucessMessage
          : sucessMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BreedImageStateImpl implements _BreedImageState {
  const _$BreedImageStateImpl(
      {this.state = UiState.initial,
      final List<BreedImage> images = const [],
      this.notification,
      this.errorMessage,
      this.sucessMessage})
      : _images = images;

  @override
  @JsonKey()
  final UiState state;
  final List<BreedImage> _images;
  @override
  @JsonKey()
  List<BreedImage> get images {
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_images);
  }

  @override
  final BreedImageNotification? notification;
  @override
  final String? errorMessage;
  @override
  final String? sucessMessage;

  @override
  String toString() {
    return 'BreedImageState(state: $state, images: $images, notification: $notification, errorMessage: $errorMessage, sucessMessage: $sucessMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BreedImageStateImpl &&
            (identical(other.state, state) || other.state == state) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            (identical(other.notification, notification) ||
                other.notification == notification) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage) &&
            (identical(other.sucessMessage, sucessMessage) ||
                other.sucessMessage == sucessMessage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      state,
      const DeepCollectionEquality().hash(_images),
      notification,
      errorMessage,
      sucessMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BreedImageStateImplCopyWith<_$BreedImageStateImpl> get copyWith =>
      __$$BreedImageStateImplCopyWithImpl<_$BreedImageStateImpl>(
          this, _$identity);
}

abstract class _BreedImageState implements BreedImageState {
  const factory _BreedImageState(
      {final UiState state,
      final List<BreedImage> images,
      final BreedImageNotification? notification,
      final String? errorMessage,
      final String? sucessMessage}) = _$BreedImageStateImpl;

  @override
  UiState get state;
  @override
  List<BreedImage> get images;
  @override
  BreedImageNotification? get notification;
  @override
  String? get errorMessage;
  @override
  String? get sucessMessage;
  @override
  @JsonKey(ignore: true)
  _$$BreedImageStateImplCopyWith<_$BreedImageStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BreedImageNotification {
  String get message => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) deletedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? deletedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? deletedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotificationDeletedError value) deletedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_NotificationDeletedError value)? deletedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotificationDeletedError value)? deletedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BreedImageNotificationCopyWith<BreedImageNotification> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BreedImageNotificationCopyWith<$Res> {
  factory $BreedImageNotificationCopyWith(BreedImageNotification value,
          $Res Function(BreedImageNotification) then) =
      _$BreedImageNotificationCopyWithImpl<$Res, BreedImageNotification>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class _$BreedImageNotificationCopyWithImpl<$Res,
        $Val extends BreedImageNotification>
    implements $BreedImageNotificationCopyWith<$Res> {
  _$BreedImageNotificationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NotificationDeletedErrorImplCopyWith<$Res>
    implements $BreedImageNotificationCopyWith<$Res> {
  factory _$$NotificationDeletedErrorImplCopyWith(
          _$NotificationDeletedErrorImpl value,
          $Res Function(_$NotificationDeletedErrorImpl) then) =
      __$$NotificationDeletedErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$NotificationDeletedErrorImplCopyWithImpl<$Res>
    extends _$BreedImageNotificationCopyWithImpl<$Res,
        _$NotificationDeletedErrorImpl>
    implements _$$NotificationDeletedErrorImplCopyWith<$Res> {
  __$$NotificationDeletedErrorImplCopyWithImpl(
      _$NotificationDeletedErrorImpl _value,
      $Res Function(_$NotificationDeletedErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$NotificationDeletedErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NotificationDeletedErrorImpl implements _NotificationDeletedError {
  _$NotificationDeletedErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'BreedImageNotification.deletedError(message: $message)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NotificationDeletedErrorImplCopyWith<_$NotificationDeletedErrorImpl>
      get copyWith => __$$NotificationDeletedErrorImplCopyWithImpl<
          _$NotificationDeletedErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) deletedError,
  }) {
    return deletedError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? deletedError,
  }) {
    return deletedError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? deletedError,
    required TResult orElse(),
  }) {
    if (deletedError != null) {
      return deletedError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotificationDeletedError value) deletedError,
  }) {
    return deletedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_NotificationDeletedError value)? deletedError,
  }) {
    return deletedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotificationDeletedError value)? deletedError,
    required TResult orElse(),
  }) {
    if (deletedError != null) {
      return deletedError(this);
    }
    return orElse();
  }
}

abstract class _NotificationDeletedError implements BreedImageNotification {
  factory _NotificationDeletedError(final String message) =
      _$NotificationDeletedErrorImpl;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$NotificationDeletedErrorImplCopyWith<_$NotificationDeletedErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
